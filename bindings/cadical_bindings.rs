/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaDiCaLSolver {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cadical_new_solver() -> *mut CaDiCaLSolver;
}
extern "C" {
    pub fn cadical_destroy(s: *mut CaDiCaLSolver);
}
extern "C" {
    pub fn cadical_vars(s: *mut CaDiCaLSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cadical_error_message(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cadical_error(solver: *mut CaDiCaLSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cadical_add_clause(
        solver: *mut CaDiCaLSolver,
        ps: *const ::std::os::raw::c_int,
        length: usize,
    );
}
extern "C" {
    pub fn cadical_add_empty_clause(solver: *mut CaDiCaLSolver);
}
extern "C" {
    pub fn cadical_add(arg1: *mut CaDiCaLSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Assume valid non zero literal for next call to 'solve'. These\n assumptions are reset after the call to 'solve' as well as after\nreturning from 'simplify' and 'lookahead.\n @param s Pointer to CaDiCaLSolver instance\n @param lit Literal to assume"]
    pub fn cadical_assume(arg1: *mut CaDiCaLSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Solve formula.\n @param s Pointer to CaDiCaLSolver instance\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn cadical_solve(arg1: *mut CaDiCaLSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get value of literal.\n @param s Pointer to CaDiCaLSolver instance\n @param lit Literal to get value\n @return (-lit=false, lit=true)"]
    pub fn cadical_val(
        arg1: *mut CaDiCaLSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Determine whether the valid non-zero literal is in the core.\n @param s Pointer to CaDiCaLSolver instance\n @param lit Literal to get failed\n @return bool value, Returns '1' if the literal is in the core and '0' otherwise."]
    pub fn cadical_failed(
        arg1: *mut CaDiCaLSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add call-back which is checked regularly for termination if terminate is nonull\n @param s Pointer to CaDiCaLSolver instance\n @param state Pointer to state\n @param terminate Pointer to termination function"]
    pub fn cadical_set_terminate(
        arg1: *mut CaDiCaLSolver,
        state: *mut ::std::os::raw::c_void,
        terminate: ::std::option::Option<
            unsafe extern "C" fn(state: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @brief Add call-back which is called when a new clause is learned.\n @param s Pointer to CaDiCaLSolver instance\n @param state Pointer to state\n @param max_length Maximum length of learned clause\n @param learn Pointer to learn function"]
    pub fn cadical_set_learn(
        arg1: *mut CaDiCaLSolver,
        state: *mut ::std::os::raw::c_void,
        max_length: ::std::os::raw::c_int,
        learn: ::std::option::Option<
            unsafe extern "C" fn(
                state: *mut ::std::os::raw::c_void,
                clause: *mut ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief dds a literal to the constraint clause. Same functionality as 'add'\n but the clause only exists for the next call to solve (same lifetime as\n assumptions). Only one constraint may exists at a time. A new\n constraint replaces the old. The main application of this functionality\n is the model checking algorithm IC3. See our FMCAD'21 paper\n [FroleyksBiere-FMCAD'19] for more details.\n @param s Pointer to CaDiCaLSolver instance\n @param lit Literal to constrain"]
    pub fn cadical_constrain(arg1: *mut CaDiCaLSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Determine whether the constraint was used to proof the\n unsatisfiability.\n @note Note that the formula might still be unsatisfiable\n without the constraint.\n @param\n @return bool value"]
    pub fn cadical_constraint_failed(arg1: *mut CaDiCaLSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set option.\n @param s Pointer to CaDiCaLSolver instance\n @param name Name of option\n @param val Value of option\n @return boolean value"]
    pub fn cadical_set_option(
        arg1: *mut CaDiCaLSolver,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Specify search limits.\n @param s Pointer to CaDiCaLSolver instance\n @param name  can be \"conflicts\", \"decisions\", \"preprocessing\", or \"localsearch\"\n @param limit Value of limit\n @return boolean value"]
    pub fn cadical_limit(
        arg1: *mut CaDiCaLSolver,
        name: *const ::std::os::raw::c_char,
        limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the current value of the option\n @param\n @param name\n @return"]
    pub fn cadical_get_option(
        arg1: *mut CaDiCaLSolver,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief print statistics\n @param\n @return"]
    pub fn cadical_print_statistics(arg1: *mut CaDiCaLSolver);
}
extern "C" {
    #[doc = " @param\n @return"]
    pub fn cadical_active(arg1: *mut CaDiCaLSolver) -> i64;
}
extern "C" {
    #[doc = " @brief The number of currently irredundant clauses can be queried by this function.\n @param\n @return"]
    pub fn cadical_irredundant(arg1: *mut CaDiCaLSolver) -> i64;
}
extern "C" {
    #[doc = " @brief Root level assigned variables can be queried with this function.\n @param s Pointer to CaDiCaLSolver instance\n @param lit Literal to get fixed\n @return  '1' if the literal is implied by the formula, '-1' if its"]
    pub fn cadical_fixed(
        arg1: *mut CaDiCaLSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cadical_conclude(arg1: *mut CaDiCaLSolver);
}
extern "C" {
    #[doc = " @brief Force termination of 'solve' asynchronously.\n @param"]
    pub fn cadical_terminate(arg1: *mut CaDiCaLSolver);
}
extern "C" {
    #[doc = " @brief\n @param\n @param lit"]
    pub fn cadical_freeze(arg1: *mut CaDiCaLSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief See our SAT'19 paper [FazekasBiereScholl-SAT'19] for more details.\n @param\n @param lit\n @return"]
    pub fn cadical_frozen(
        arg1: *mut CaDiCaLSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cadical_melt(arg1: *mut CaDiCaLSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief This function executes the given number of preprocessing rounds. It is\n similar to 'solve' with 'limits (\"preprocessing\", rounds)' except that\n no CDCL nor local search, nor lucky phases are executed.\n @param\n @return  10=SATISFIABLE, 20=UNSATISFIABLE, 30=UNKNOWN,."]
    pub fn cadical_simplify(arg1: *mut CaDiCaLSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allocate clauses in arena\n @param s Pointer to CaDiCaLSolver instance\n @param arena Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_arena(
        s: *mut CaDiCaLSolver,
        arena: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Keep clauses compact\n @param s Pointer to CaDiCaLSolver instance\n @param arenacompact Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_arenacompact(
        s: *mut CaDiCaLSolver,
        arenacompact: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sort clauses in arena\n @param s Pointer to CaDiCaLSolver instance\n @param arenasort Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_arenasort(
        s: *mut CaDiCaLSolver,
        arenasort: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set arena type (1=clause, 2=var, 3=queue)\n @param s Pointer to CaDiCaLSolver instance\n @param arenatype Integer value (1 to 3)\n @return boolean value"]
    pub fn cadical_set_opt_arenatype(
        s: *mut CaDiCaLSolver,
        arenatype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use binary proof format\n @param s Pointer to CaDiCaLSolver instance\n @param binary Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_binary(
        s: *mut CaDiCaLSolver,
        binary: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable blocked clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param block Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_block(
        s: *mut CaDiCaLSolver,
        block: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum clause size for blocked clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param blockmaxclslim Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_blockmaxclslim(
        s: *mut CaDiCaLSolver,
        blockmaxclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum clause size for blocked clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param blockminclslim Integer value (2 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_blockminclslim(
        s: *mut CaDiCaLSolver,
        blockminclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set occurrence limit for blocked clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param blockocclim Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_blockocclim(
        s: *mut CaDiCaLSolver,
        blockocclim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Bump variables\n @param s Pointer to CaDiCaLSolver instance\n @param bump Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_bump(
        s: *mut CaDiCaLSolver,
        bump: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Bump reason literals too\n @param s Pointer to CaDiCaLSolver instance\n @param bumpreason Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_bumpreason(
        s: *mut CaDiCaLSolver,
        bumpreason: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set bump reason depth\n @param s Pointer to CaDiCaLSolver instance\n @param bumpreasondepth Integer value (1 to 3)\n @return boolean value"]
    pub fn cadical_set_opt_bumpreasondepth(
        s: *mut CaDiCaLSolver,
        bumpreasondepth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable internal checking\n @param s Pointer to CaDiCaLSolver instance\n @param check Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_check(
        s: *mut CaDiCaLSolver,
        check: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check assumptions satisfied\n @param s Pointer to CaDiCaLSolver instance\n @param checkassumptions Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_checkassumptions(
        s: *mut CaDiCaLSolver,
        checkassumptions: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check constraint satisfied\n @param s Pointer to CaDiCaLSolver instance\n @param checkconstraint Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_checkconstraint(
        s: *mut CaDiCaLSolver,
        checkconstraint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check failed literals form core\n @param s Pointer to CaDiCaLSolver instance\n @param checkfailed Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_checkfailed(
        s: *mut CaDiCaLSolver,
        checkfailed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check all frozen semantics\n @param s Pointer to CaDiCaLSolver instance\n @param checkfrozen Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_checkfrozen(
        s: *mut CaDiCaLSolver,
        checkfrozen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set proof checking mode (1=drat, 2=lrat, 3=both)\n @param s Pointer to CaDiCaLSolver instance\n @param checkproof Integer value (0 to 3)\n @return boolean value"]
    pub fn cadical_set_opt_checkproof(
        s: *mut CaDiCaLSolver,
        checkproof: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check witness internally\n @param s Pointer to CaDiCaLSolver instance\n @param checkwitness Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_checkwitness(
        s: *mut CaDiCaLSolver,
        checkwitness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set chronological backtracking mode\n @param s Pointer to CaDiCaLSolver instance\n @param chrono Integer value (0 to 2)\n @return boolean value"]
    pub fn cadical_set_opt_chrono(
        s: *mut CaDiCaLSolver,
        chrono: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Force always chronological backtracking\n @param s Pointer to CaDiCaLSolver instance\n @param chronoalways Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_chronoalways(
        s: *mut CaDiCaLSolver,
        chronoalways: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set chronological level limit\n @param s Pointer to CaDiCaLSolver instance\n @param chronolevelim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_chronolevelim(
        s: *mut CaDiCaLSolver,
        chronolevelim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Reuse trail chronologically\n @param s Pointer to CaDiCaLSolver instance\n @param chronoreusetrail Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_chronoreusetrail(
        s: *mut CaDiCaLSolver,
        chronoreusetrail: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compact internal variables\n @param s Pointer to CaDiCaLSolver instance\n @param compact Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_compact(
        s: *mut CaDiCaLSolver,
        compact: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set compacting interval\n @param s Pointer to CaDiCaLSolver instance\n @param compactint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_compactint(
        s: *mut CaDiCaLSolver,
        compactint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set inactive limit per mille\n @param s Pointer to CaDiCaLSolver instance\n @param compactlim Integer value (0 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_compactlim(
        s: *mut CaDiCaLSolver,
        compactlim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum inactive limit\n @param s Pointer to CaDiCaLSolver instance\n @param compactmin Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_compactmin(
        s: *mut CaDiCaLSolver,
        compactmin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable globally blocked clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param condition Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_condition(
        s: *mut CaDiCaLSolver,
        condition: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set initial conflict interval for condition\n @param s Pointer to CaDiCaLSolver instance\n @param conditionint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_conditionint(
        s: *mut CaDiCaLSolver,
        conditionint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum condition efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param conditionmaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_conditionmaxeff(
        s: *mut CaDiCaLSolver,
        conditionmaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum clause variable ratio\n @param s Pointer to CaDiCaLSolver instance\n @param conditionmaxrat Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_conditionmaxrat(
        s: *mut CaDiCaLSolver,
        conditionmaxrat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum condition efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param conditionmineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_conditionmineff(
        s: *mut CaDiCaLSolver,
        conditionmineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for condition\n @param s Pointer to CaDiCaLSolver instance\n @param conditionreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_conditionreleff(
        s: *mut CaDiCaLSolver,
        conditionreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable covered clause elimination\n @param s Pointer to CaDiCaLSolver instance\n @param cover Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_cover(
        s: *mut CaDiCaLSolver,
        cover: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum clause size for cover\n @param s Pointer to CaDiCaLSolver instance\n @param covermaxclslim Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_covermaxclslim(
        s: *mut CaDiCaLSolver,
        covermaxclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum cover efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param covermaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_covermaxeff(
        s: *mut CaDiCaLSolver,
        covermaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum clause size for cover\n @param s Pointer to CaDiCaLSolver instance\n @param coverminclslim Integer value (2 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_coverminclslim(
        s: *mut CaDiCaLSolver,
        coverminclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum cover efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param covermineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_covermineff(
        s: *mut CaDiCaLSolver,
        covermineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for cover\n @param s Pointer to CaDiCaLSolver instance\n @param coverreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_coverreleff(
        s: *mut CaDiCaLSolver,
        coverreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decompose BIG in SCCs and ELS\n @param s Pointer to CaDiCaLSolver instance\n @param decompose Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_decompose(
        s: *mut CaDiCaLSolver,
        decompose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set number of decompose rounds\n @param s Pointer to CaDiCaLSolver instance\n @param decomposerounds Integer value (1 to 16)\n @return boolean value"]
    pub fn cadical_set_opt_decomposerounds(
        s: *mut CaDiCaLSolver,
        decomposerounds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove duplicated binaries\n @param s Pointer to CaDiCaLSolver instance\n @param deduplicate Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_deduplicate(
        s: *mut CaDiCaLSolver,
        deduplicate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Subsume recently learned clauses\n @param s Pointer to CaDiCaLSolver instance\n @param eagersubsume Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_eagersubsume(
        s: *mut CaDiCaLSolver,
        eagersubsume: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set limit on subsumed candidates\n @param s Pointer to CaDiCaLSolver instance\n @param eagersubsumelim Integer value (1 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_eagersubsumelim(
        s: *mut CaDiCaLSolver,
        eagersubsumelim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable bounded variable elimination\n @param s Pointer to CaDiCaLSolver instance\n @param elim Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elim(
        s: *mut CaDiCaLSolver,
        elim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find AND gates\n @param s Pointer to CaDiCaLSolver instance\n @param elimands Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimands(
        s: *mut CaDiCaLSolver,
        elimands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum elimination efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param elimaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_elimaxeff(
        s: *mut CaDiCaLSolver,
        elimaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable eager backward subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param elimbackward Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimbackward(
        s: *mut CaDiCaLSolver,
        elimbackward: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum elimination bound\n @param s Pointer to CaDiCaLSolver instance\n @param elimboundmax Integer value (-1 to 2e6)\n @return boolean value"]
    pub fn cadical_set_opt_elimboundmax(
        s: *mut CaDiCaLSolver,
        elimboundmax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum elimination bound\n @param s Pointer to CaDiCaLSolver instance\n @param elimboundmin Integer value (-1 to 2e6)\n @return boolean value"]
    pub fn cadical_set_opt_elimboundmin(
        s: *mut CaDiCaLSolver,
        elimboundmin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set resolvent size limit\n @param s Pointer to CaDiCaLSolver instance\n @param elimclslim Integer value (2 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_elimclslim(
        s: *mut CaDiCaLSolver,
        elimclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find equivalence gates\n @param s Pointer to CaDiCaLSolver instance\n @param elimequivs Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimequivs(
        s: *mut CaDiCaLSolver,
        elimequivs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum elimination efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param elimineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_elimineff(
        s: *mut CaDiCaLSolver,
        elimineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set elimination interval\n @param s Pointer to CaDiCaLSolver instance\n @param elimint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_elimint(
        s: *mut CaDiCaLSolver,
        elimint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find if-then-else gates\n @param s Pointer to CaDiCaLSolver instance\n @param elimites Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimites(
        s: *mut CaDiCaLSolver,
        elimites: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Limit resolutions\n @param s Pointer to CaDiCaLSolver instance\n @param elimlimited Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimlimited(
        s: *mut CaDiCaLSolver,
        elimlimited: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set occurrence limit for elimination\n @param s Pointer to CaDiCaLSolver instance\n @param elimocclim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_elimocclim(
        s: *mut CaDiCaLSolver,
        elimocclim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set elimination score product weight\n @param s Pointer to CaDiCaLSolver instance\n @param elimprod Integer value (0 to 1e4)\n @return boolean value"]
    pub fn cadical_set_opt_elimprod(
        s: *mut CaDiCaLSolver,
        elimprod: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for elimination\n @param s Pointer to CaDiCaLSolver instance\n @param elimreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_elimreleff(
        s: *mut CaDiCaLSolver,
        elimreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set usual number of elimination rounds\n @param s Pointer to CaDiCaLSolver instance\n @param elimrounds Integer value (1 to 512)\n @return boolean value"]
    pub fn cadical_set_opt_elimrounds(
        s: *mut CaDiCaLSolver,
        elimrounds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable elimination by substitution\n @param s Pointer to CaDiCaLSolver instance\n @param elimsubst Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimsubst(
        s: *mut CaDiCaLSolver,
        elimsubst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set elimination score sum weight\n @param s Pointer to CaDiCaLSolver instance\n @param elimsum Integer value (0 to 1e4)\n @return boolean value"]
    pub fn cadical_set_opt_elimsum(
        s: *mut CaDiCaLSolver,
        elimsum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum XOR size\n @param s Pointer to CaDiCaLSolver instance\n @param elimxorlim Integer value (2 to 27)\n @return boolean value"]
    pub fn cadical_set_opt_elimxorlim(
        s: *mut CaDiCaLSolver,
        elimxorlim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find XOR gates\n @param s Pointer to CaDiCaLSolver instance\n @param elimxors Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_elimxors(
        s: *mut CaDiCaLSolver,
        elimxors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window fast glue\n @param s Pointer to CaDiCaLSolver instance\n @param emagluefast Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_emagluefast(
        s: *mut CaDiCaLSolver,
        emagluefast: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window slow glue\n @param s Pointer to CaDiCaLSolver instance\n @param emaglueslow Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_emaglueslow(
        s: *mut CaDiCaLSolver,
        emaglueslow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window back-jump level\n @param s Pointer to CaDiCaLSolver instance\n @param emajump Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_emajump(
        s: *mut CaDiCaLSolver,
        emajump: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window back-track level\n @param s Pointer to CaDiCaLSolver instance\n @param emalevel Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_emalevel(
        s: *mut CaDiCaLSolver,
        emalevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window learned clause size\n @param s Pointer to CaDiCaLSolver instance\n @param emasize Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_emasize(
        s: *mut CaDiCaLSolver,
        emasize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window fast trail\n @param s Pointer to CaDiCaLSolver instance\n @param ematrailfast Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_ematrailfast(
        s: *mut CaDiCaLSolver,
        ematrailfast: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set window slow trail\n @param s Pointer to CaDiCaLSolver instance\n @param ematrailslow Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_ematrailslow(
        s: *mut CaDiCaLSolver,
        ematrailslow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Eagerly ask for all reasons (0: only when needed)\n @param s Pointer to CaDiCaLSolver instance\n @param exteagerreasons Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_exteagerreasons(
        s: *mut CaDiCaLSolver,
        exteagerreasons: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Recalculate all levels after eagerly asking for reasons (0: trust the external tool)\n @param s Pointer to CaDiCaLSolver instance\n @param exteagerrecalc Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_exteagerrecalc(
        s: *mut CaDiCaLSolver,
        exteagerrecalc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable external LRAT\n @param s Pointer to CaDiCaLSolver instance\n @param externallrat Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_externallrat(
        s: *mut CaDiCaLSolver,
        externallrat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Flush redundant clauses\n @param s Pointer to CaDiCaLSolver instance\n @param flush Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_flush(
        s: *mut CaDiCaLSolver,
        flush: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set interval increase for flushing\n @param s Pointer to CaDiCaLSolver instance\n @param flushfactor Integer value (1 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_flushfactor(
        s: *mut CaDiCaLSolver,
        flushfactor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set initial limit for flushing\n @param s Pointer to CaDiCaLSolver instance\n @param flushint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_flushint(
        s: *mut CaDiCaLSolver,
        flushint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Always use initial phase\n @param s Pointer to CaDiCaLSolver instance\n @param forcephase Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_forcephase(
        s: *mut CaDiCaLSolver,
        forcephase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set FRAT proof format (1=frat(lrat), 2=frat(drat))\n @param s Pointer to CaDiCaLSolver instance\n @param frat Integer value (0 to 2)\n @return boolean value"]
    pub fn cadical_set_opt_frat(
        s: *mut CaDiCaLSolver,
        frat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use incremental proof format\n @param s Pointer to CaDiCaLSolver instance\n @param idrup Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_idrup(
        s: *mut CaDiCaLSolver,
        idrup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable ILB (incremental lazy backtrack)\n @param s Pointer to CaDiCaLSolver instance\n @param ilb Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_ilb(
        s: *mut CaDiCaLSolver,
        ilb: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable trail reuse for assumptions (ILB-like)\n @param s Pointer to CaDiCaLSolver instance\n @param ilbassumptions Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_ilbassumptions(
        s: *mut CaDiCaLSolver,
        ilbassumptions: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable inprocessing\n @param s Pointer to CaDiCaLSolver instance\n @param inprocessing Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_inprocessing(
        s: *mut CaDiCaLSolver,
        inprocessing: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable variable instantiation\n @param s Pointer to CaDiCaLSolver instance\n @param instantiate Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_instantiate(
        s: *mut CaDiCaLSolver,
        instantiate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum clause size for instantiation\n @param s Pointer to CaDiCaLSolver instance\n @param instantiateclslim Integer value (2 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_instantiateclslim(
        s: *mut CaDiCaLSolver,
        instantiateclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum occurrence limit for instantiation\n @param s Pointer to CaDiCaLSolver instance\n @param instantiateocclim Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_instantiateocclim(
        s: *mut CaDiCaLSolver,
        instantiateocclim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instantiate each clause once\n @param s Pointer to CaDiCaLSolver instance\n @param instantiateonce Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_instantiateonce(
        s: *mut CaDiCaLSolver,
        instantiateonce: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use linear incremental proof format\n @param s Pointer to CaDiCaLSolver instance\n @param lidrup Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_lidrup(
        s: *mut CaDiCaLSolver,
        lidrup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable logging\n @param s Pointer to CaDiCaLSolver instance\n @param log Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_log(
        s: *mut CaDiCaLSolver,
        log: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sort logged clauses\n @param s Pointer to CaDiCaLSolver instance\n @param logsort Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_logsort(
        s: *mut CaDiCaLSolver,
        logsort: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use LRAT proof format\n @param s Pointer to CaDiCaLSolver instance\n @param lrat Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_lrat(
        s: *mut CaDiCaLSolver,
        lrat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Search for lucky phases\n @param s Pointer to CaDiCaLSolver instance\n @param lucky Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_lucky(
        s: *mut CaDiCaLSolver,
        lucky: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Minimize learned clauses\n @param s Pointer to CaDiCaLSolver instance\n @param minimize Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_minimize(
        s: *mut CaDiCaLSolver,
        minimize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimization depth\n @param s Pointer to CaDiCaLSolver instance\n @param minimizedepth Integer value (0 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_minimizedepth(
        s: *mut CaDiCaLSolver,
        minimizedepth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable on-the-fly self subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param otfs Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_otfs(
        s: *mut CaDiCaLSolver,
        otfs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set initial phase\n @param s Pointer to CaDiCaLSolver instance\n @param phase Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_phase(
        s: *mut CaDiCaLSolver,
        phase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable failed literal probing\n @param s Pointer to CaDiCaLSolver instance\n @param probe Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_probe(
        s: *mut CaDiCaLSolver,
        probe: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Learn hyper binary clauses\n @param s Pointer to CaDiCaLSolver instance\n @param probehbr Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_probehbr(
        s: *mut CaDiCaLSolver,
        probehbr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set probing interval\n @param s Pointer to CaDiCaLSolver instance\n @param probeint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_probeint(
        s: *mut CaDiCaLSolver,
        probeint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum probing efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param probemaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_probemaxeff(
        s: *mut CaDiCaLSolver,
        probemaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum probing efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param probemineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_probemineff(
        s: *mut CaDiCaLSolver,
        probemineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for probing\n @param s Pointer to CaDiCaLSolver instance\n @param probereleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_probereleff(
        s: *mut CaDiCaLSolver,
        probereleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set probing rounds\n @param s Pointer to CaDiCaLSolver instance\n @param proberounds Integer value (1 to 16)\n @return boolean value"]
    pub fn cadical_set_opt_proberounds(
        s: *mut CaDiCaLSolver,
        proberounds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set profiling level\n @param s Pointer to CaDiCaLSolver instance\n @param profile Integer value (0 to 4)\n @return boolean value"]
    pub fn cadical_set_opt_profile(
        s: *mut CaDiCaLSolver,
        profile: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Disable all messages\n @param s Pointer to CaDiCaLSolver instance\n @param quiet Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_quiet(
        s: *mut CaDiCaLSolver,
        quiet: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set radix sort limit\n @param s Pointer to CaDiCaLSolver instance\n @param radixsortlim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_radixsortlim(
        s: *mut CaDiCaLSolver,
        radixsortlim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use real instead of process time\n @param s Pointer to CaDiCaLSolver instance\n @param realtime Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_realtime(
        s: *mut CaDiCaLSolver,
        realtime: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Reduce useless clauses\n @param s Pointer to CaDiCaLSolver instance\n @param reduce Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_reduce(
        s: *mut CaDiCaLSolver,
        reduce: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set reduce interval\n @param s Pointer to CaDiCaLSolver instance\n @param reduceint Integer value (10 to 1e6)\n @return boolean value"]
    pub fn cadical_set_opt_reduceint(
        s: *mut CaDiCaLSolver,
        reduceint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set reduce fraction in percent\n @param s Pointer to CaDiCaLSolver instance\n @param reducetarget Integer value (10 to 1e2)\n @return boolean value"]
    pub fn cadical_set_opt_reducetarget(
        s: *mut CaDiCaLSolver,
        reducetarget: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set glue of kept learned clauses\n @param s Pointer to CaDiCaLSolver instance\n @param reducetier1glue Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_reducetier1glue(
        s: *mut CaDiCaLSolver,
        reducetier1glue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set glue of tier two clauses\n @param s Pointer to CaDiCaLSolver instance\n @param reducetier2glue Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_reducetier2glue(
        s: *mut CaDiCaLSolver,
        reducetier2glue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set reluctant doubling period\n @param s Pointer to CaDiCaLSolver instance\n @param reluctant Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_reluctant(
        s: *mut CaDiCaLSolver,
        reluctant: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum reluctant doubling period\n @param s Pointer to CaDiCaLSolver instance\n @param reluctantmax Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_reluctantmax(
        s: *mut CaDiCaLSolver,
        reluctantmax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable resetting phase\n @param s Pointer to CaDiCaLSolver instance\n @param rephase Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_rephase(
        s: *mut CaDiCaLSolver,
        rephase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set rephase interval\n @param s Pointer to CaDiCaLSolver instance\n @param rephaseint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_rephaseint(
        s: *mut CaDiCaLSolver,
        rephaseint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable reporting\n @param s Pointer to CaDiCaLSolver instance\n @param report Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_report(
        s: *mut CaDiCaLSolver,
        report: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Report even if not successful\n @param s Pointer to CaDiCaLSolver instance\n @param reportall Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_reportall(
        s: *mut CaDiCaLSolver,
        reportall: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use solving not process time for reporting\n @param s Pointer to CaDiCaLSolver instance\n @param reportsolve Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_reportsolve(
        s: *mut CaDiCaLSolver,
        reportsolve: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable restarts\n @param s Pointer to CaDiCaLSolver instance\n @param restart Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_restart(
        s: *mut CaDiCaLSolver,
        restart: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set restart interval\n @param s Pointer to CaDiCaLSolver instance\n @param restartint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_restartint(
        s: *mut CaDiCaLSolver,
        restartint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set slow fast margin in percent\n @param s Pointer to CaDiCaLSolver instance\n @param restartmargin Integer value (0 to 1e2)\n @return boolean value"]
    pub fn cadical_set_opt_restartmargin(
        s: *mut CaDiCaLSolver,
        restartmargin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable trail reuse\n @param s Pointer to CaDiCaLSolver instance\n @param restartreusetrail Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_restartreusetrail(
        s: *mut CaDiCaLSolver,
        restartreusetrail: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Restore all clauses (2=really)\n @param s Pointer to CaDiCaLSolver instance\n @param restoreall Integer value (0 to 2)\n @return boolean value"]
    pub fn cadical_set_opt_restoreall(
        s: *mut CaDiCaLSolver,
        restoreall: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove satisfied clauses\n @param s Pointer to CaDiCaLSolver * instance\n @param restoreflush Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_restoreflush(
        s: *mut CaDiCaLSolver,
        restoreflush: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Reverse variable ordering\n @param s Pointer to CaDiCaLSolver instance\n @param reverse Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_reverse(
        s: *mut CaDiCaLSolver,
        reverse: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use EVSIDS scores\n @param s Pointer to CaDiCaLSolver instance\n @param score Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_score(
        s: *mut CaDiCaLSolver,
        score: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set score factor per mille\n @param s Pointer to CaDiCaLSolver instance\n @param scorefactor Integer value (500 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_scorefactor(
        s: *mut CaDiCaLSolver,
        scorefactor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set random seed\n @param s Pointer to CaDiCaLSolver instance\n @param seed Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_seed(
        s: *mut CaDiCaLSolver,
        seed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shrink conflict clause (1=only with binary, 2=minimize when pulling, 3=full)\n @param s Pointer to CaDiCaLSolver instance\n @param shrink Integer value (0 to 3)\n @return boolean value"]
    pub fn cadical_set_opt_shrink(
        s: *mut CaDiCaLSolver,
        shrink: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use a reap for shrinking\n @param s Pointer to CaDiCaLSolver instance\n @param shrinkreap Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_shrinkreap(
        s: *mut CaDiCaLSolver,
        shrinkreap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shuffle variables\n @param s Pointer to CaDiCaLSolver instance\n @param shuffle Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_shuffle(
        s: *mut CaDiCaLSolver,
        shuffle: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shuffle variable queue\n @param s Pointer to CaDiCaLSolver instance\n @param shufflequeue Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_shufflequeue(
        s: *mut CaDiCaLSolver,
        shufflequeue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use random instead of reverse shuffling\n @param s Pointer to CaDiCaLSolver instance\n @param shufflerandom Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_shufflerandom(
        s: *mut CaDiCaLSolver,
        shufflerandom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shuffle variable scores\n @param s Pointer to CaDiCaLSolver instance\n @param shufflescores Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_shufflescores(
        s: *mut CaDiCaLSolver,
        shufflescores: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable stabilizing phases\n @param s Pointer to CaDiCaLSolver instance\n @param stabilize Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_stabilize(
        s: *mut CaDiCaLSolver,
        stabilize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set phase increase in percent\n @param s Pointer to CaDiCaLSolver instance\n @param stabilizefactor Integer value (101 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_stabilizefactor(
        s: *mut CaDiCaLSolver,
        stabilizefactor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set stabilizing interval\n @param s Pointer to CaDiCaLSolver instance\n @param stabilizeint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_stabilizeint(
        s: *mut CaDiCaLSolver,
        stabilizeint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum stabilizing phase\n @param s Pointer to CaDiCaLSolver instance\n @param stabilizemaxint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_stabilizemaxint(
        s: *mut CaDiCaLSolver,
        stabilizemaxint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use only stabilizing phases\n @param s Pointer to CaDiCaLSolver instance\n @param stabilizeonly Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_stabilizeonly(
        s: *mut CaDiCaLSolver,
        stabilizeonly: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Print all statistics at the end of the run\n @param s Pointer to CaDiCaLSolver instance\n @param stats Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_stats(
        s: *mut CaDiCaLSolver,
        stats: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable clause subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param subsume Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_subsume(
        s: *mut CaDiCaLSolver,
        subsume: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set watch list length limit for subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param subsumebinlim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumebinlim(
        s: *mut CaDiCaLSolver,
        subsumebinlim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set clause length limit for subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param subsumeclslim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumeclslim(
        s: *mut CaDiCaLSolver,
        subsumeclslim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set subsume interval\n @param s Pointer to CaDiCaLSolver instance\n @param subsumeint Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumeint(
        s: *mut CaDiCaLSolver,
        subsumeint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Limit subsumption checks\n @param s Pointer to CaDiCaLSolver instance\n @param subsumelimited Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_subsumelimited(
        s: *mut CaDiCaLSolver,
        subsumelimited: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum subsuming efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param subsumemaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumemaxeff(
        s: *mut CaDiCaLSolver,
        subsumemaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum subsuming efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param subsumemineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumemineff(
        s: *mut CaDiCaLSolver,
        subsumemineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set watch list length limit for subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param subsumeocclim Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_subsumeocclim(
        s: *mut CaDiCaLSolver,
        subsumeocclim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for subsumption\n @param s Pointer to CaDiCaLSolver instance\n @param subsumereleff Integer value ers (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_subsumereleff(
        s: *mut CaDiCaLSolver,
        subsumereleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Strengthen during subsume\n @param s Pointer to CaDiCaLSolver instance\n @param subsumestr Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_subsumestr(
        s: *mut CaDiCaLSolver,
        subsumestr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set target phases (1=stable only)\n @param s Pointer to CaDiCaLSolver instance\n @param target Integer value (0 to 2)\n @return boolean value"]
    pub fn cadical_set_opt_target(
        s: *mut CaDiCaLSolver,
        target: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set termination check interval\n @param s Pointer to CaDiCaLSolver instance\n @param terminateint Integer value (0 to 1e4)\n @return boolean value"]
    pub fn cadical_set_opt_terminateint(
        s: *mut CaDiCaLSolver,
        terminateint: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable hyper ternary resolution\n @param s Pointer to CaDiCaLSolver instance\n @param ternary Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_ternary(
        s: *mut CaDiCaLSolver,
        ternary: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set max clauses added in percent for ternary\n @param s Pointer to CaDiCaLSolver instance\n @param ternarymaxadd Integer value (0 to 1e4)\n @return boolean value"]
    pub fn cadical_set_opt_ternarymaxadd(
        s: *mut CaDiCaLSolver,
        ternarymaxadd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set ternary maximum efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param ternarymaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_ternarymaxeff(
        s: *mut CaDiCaLSolver,
        ternarymaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum ternary efficiency\n @param s Pointer to CaDiCaLSolver instance\n @param ternarymineff Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_ternarymineff(
        s: *mut CaDiCaLSolver,
        ternarymineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set ternary occurrence limit\n @param s Pointer to CaDiCaLSolver instance\n @param ternaryocclim Integer value (1 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_ternaryocclim(
        s: *mut CaDiCaLSolver,
        ternaryocclim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for ternary\n @param s Pointer to CaDiCaLSolver instance\n @param ternaryreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_ternaryreleff(
        s: *mut CaDiCaLSolver,
        ternaryreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum ternary rounds\n @param s Pointer to CaDiCaLSolver instance\n @param ternaryrounds Integer value (1 to 16)\n @return boolean value"]
    pub fn cadical_set_opt_ternaryrounds(
        s: *mut CaDiCaLSolver,
        ternaryrounds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable transitive reduction of BIG\n @param s Pointer to CaDiCaLSolver instance\n @param transred Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_transred(
        s: *mut CaDiCaLSolver,
        transred: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum efficiency for transitive reduction\n @param s Pointer to CaDiCaLSolver instance\n @param transredmaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_transredmaxeff(
        s: *mut CaDiCaLSolver,
        transredmaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum efficiency for transitive reduction\n @param s Pointer to CaDiCaLSolver instance\n @param transredmineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_transredmineff(
        s: *mut CaDiCaLSolver,
        transredmineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for transitive reduction\n @param s Pointer to CaDiCaLSolver instance\n @param transredreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_transredreleff(
        s: *mut CaDiCaLSolver,
        transredreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set verbose message level\n @param s Pointer to CaDiCaLSolver instance\n @param verbose Integer value (0 to 3)\n @return boolean value"]
    pub fn cadical_set_opt_verbose(
        s: *mut CaDiCaLSolver,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set VeriPB mode (odd=checkdeletions, > 2=drat)\n @param s Pointer to CaDiCaLSolver instance\n @param veripb Integer value (0 to 4)\n @return boolean value"]
    pub fn cadical_set_opt_veripb(
        s: *mut CaDiCaLSolver,
        veripb: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable vivification\n @param s Pointer to CaDiCaLSolver instance\n @param vivify Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_vivify(
        s: *mut CaDiCaLSolver,
        vivify: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instantiate last literal when vivifying\n @param s Pointer to CaDiCaLSolver instance\n @param vivifyinst Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_vivifyinst(
        s: *mut CaDiCaLSolver,
        vivifyinst: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum efficiency for vivification\n @param s Pointer to CaDiCaLSolver instance\n @param vivifymaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_vivifymaxeff(
        s: *mut CaDiCaLSolver,
        vivifymaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum efficiency for vivification\n @param s Pointer to CaDiCaLSolver instance\n @param vivifymineff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_vivifymineff(
        s: *mut CaDiCaLSolver,
        vivifymineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set vivify once mode (1=red, 2=red+irr)\n @param s Pointer to CaDiCaLSolver instance\n @param vivifyonce Integer value (0 to 2)\n @return boolean value"]
    pub fn cadical_set_opt_vivifyonce(
        s: *mut CaDiCaLSolver,
        vivifyonce: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set redundant efficiency per mille for vivification\n @param s Pointer to CaDiCaLSolver instance\n @param vivifyredeff Integer value (0 to 1e3)\n @return boolean value"]
    pub fn cadical_set_opt_vivifyredeff(
        s: *mut CaDiCaLSolver,
        vivifyredeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for vivification\n @param s Pointer to CaDiCaLSolver instance\n @param vivifyreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_vivifyreleff(
        s: *mut CaDiCaLSolver,
        vivifyreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable random walks\n @param s Pointer to CaDiCaLSolver instance\n @param walk Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_walk(
        s: *mut CaDiCaLSolver,
        walk: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set maximum efficiency for random walks\n @param s Pointer to CaDiCaLSolver instance\n @param walkmaxeff Integer value (0 to 2e9)\n @return boolean value"]
    pub fn cadical_set_opt_walkmaxeff(
        s: *mut CaDiCaLSolver,
        walkmaxeff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set minimum efficiency for random walks\n @param s Pointer to CaDiCaLSolver instance\n @param walkmineff Integer value (0 to 1e7)\n @return boolean value"]
    pub fn cadical_set_opt_walkmineff(
        s: *mut CaDiCaLSolver,
        walkmineff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Walk in non-stabilizing phase\n @param s Pointer to CaDiCaLSolver instance\n @param walknonstable Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_walknonstable(
        s: *mut CaDiCaLSolver,
        walknonstable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Walk redundant clauses too\n @param s Pointer to CaDiCaLSolver instance\n @param walkredundant Boolean value\n @return boolean value"]
    pub fn cadical_set_opt_walkredundant(
        s: *mut CaDiCaLSolver,
        walkredundant: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set relative efficiency per mille for random walks\n @param s Pointer to CaDiCaLSolver instance\n @param walkreleff Integer value (1 to 1e5)\n @return boolean value"]
    pub fn cadical_set_opt_walkreleff(
        s: *mut CaDiCaLSolver,
        walkreleff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
