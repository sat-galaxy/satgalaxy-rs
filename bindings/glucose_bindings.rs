/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlucoseSolver {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief get error message by error code\n @param code error code\n @return message"]
    pub fn glucose_error_msg(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn glucose_error( arg1: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The constant used to force restart\n @param value must be in (0, 1)\n @return error code"]
    pub fn glucose_set_global_opt_K(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The constant used to block restart\n @param value must be in (0, 5)\n @return error code"]
    pub fn glucose_set_global_opt_R(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The size of moving average for LBD (restarts)\n @param value must be at least 10\n @return error code"]
    pub fn glucose_set_global_opt_size_lbd_queue(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The size of moving average for trail (block restarts)\n @param value  must be at least 10\n @return error code"]
    pub fn glucose_set_global_opt_size_trail_queue(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The number of conflicts before the first reduce DB (or the size of learnts if chanseok is used)\n @param value  must be a non-negative integer\n @return error code"]
    pub fn glucose_set_global_opt_first_reduce_db(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Increment for reduce DB\n @param value  must be a non-negative integer\n @return error code"]
    pub fn glucose_set_global_opt_inc_reduce_db(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Special increment for reduce DB\n @param value must be a non-negative integer\n @return error code"]
    pub fn glucose_set_global_opt_spec_inc_reduce_db(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Protect clauses if their LBD decrease and is lower than (for one turn)\n @param value must be a non-negative integer\n @return error code"]
    pub fn glucose_set_global_opt_lb_lbd_frozen_clause(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use Chanseok Oh strategy for LBD (keep all LBD<=co and remove half of firstreduceDB other learnt clauses)\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_chanseok_hack(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Chanseok Oh: all learnt clauses with LBD<=co are permanent\n @param value must be a positive integer greater than 1\n @return error code"]
    pub fn glucose_set_global_opt_chanseok_limit(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The min size required to minimize clause\n @param value must be at least 3\n @return error code"]
    pub fn glucose_set_global_opt_lb_size_minimzing_clause(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The min LBD required to minimize clause\n @param value must be at least 3\n @return error code"]
    pub fn glucose_set_global_opt_lb_lbd_minimzing_clause(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use inprocessing vivif (ijcai17 paper)\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_lcm(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Updates LBD when doing LCM\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_lcm_update_lbd(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The variable activity decay factor (starting point)\n @param value must be in (0, 1)\n @return error code"]
    pub fn glucose_set_global_opt_var_decay(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The maximum variable activity decay factor\n @param value must be in (0, 1)\n @return error code"]
    pub fn glucose_set_global_opt_max_var_decay(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The clause activity decay factor\n @param value must be in (0, 1)\n @return error code"]
    pub fn glucose_set_global_opt_clause_decay(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The frequency with which the decision heuristic tries to choose a random variable\n @param value  must be in [0, 1]\n @return error code"]
    pub fn glucose_set_global_opt_random_var_freq(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Used by the random variable selection\n @param value must be positive\n @return error code"]
    pub fn glucose_set_global_opt_random_seed(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Controls conflict clause minimization (0=none, 1=basic, 2=deep)\n @param value must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_global_opt_ccmin_mode(value: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls phase saving (0=none, 1=basic, 2=deep)\n @param value must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_global_opt_phase_saving(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Randomize the initial activity\n @param value  boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_rnd_init_act(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered\n @param value must be positive\n @return error code"]
    pub fn glucose_set_global_opt_garbage_frac(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief glucose strategy to fire clause database reduction (must be false to fire Chanseok strategy)\n @param value  boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_glu_reduction(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Use the Luby restart sequence\n @param value  boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_luby_restart(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Restart interval increase factor\n @param value must be at least 1.0\n @return error code"]
    pub fn glucose_set_global_opt_restart_inc(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Luby restart factor\n @param value must be a positive integer\n @return error code"]
    pub fn glucose_set_global_opt_luby_restart_factor(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The amount of randomization for the phase at each restart (0=none, 1=first branch, 2=first branch (no bad clauses), 3=first branch (only initial clauses))\n @param value must be 0, 1, 2, or 3\n @return error code"]
    pub fn glucose_set_global_opt_randomize_phase_on_restarts(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fixes the first 7 levels at random phase\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_fixed_randomize_phase_on_restarts(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Adapt dynamically stategies after 100000 conflicts\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_adapt(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Force the phase for UNSAT\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_forceunsat(value: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shrink clauses by asymmetric branching\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_use_asymm(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check if a clause is already implied. (costly)\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_use_rcheck(value: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Perform variable elimination.\n @param value boolean value (1=true, 0=false)\n @return error code"]
    pub fn glucose_set_global_opt_use_elim(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Allow a variable elimination step to grow by a number of clauses.\n @param value\n @return error code"]
    pub fn glucose_set_global_opt_grow(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit\n @param value must be -1 or a positive integer\n @return error code"]
    pub fn glucose_set_global_opt_clause_lim(value: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Do not check if subsumption against a clause larger than this. -1 means no limit.\n @param value must be -1 or a positive integer\n @return error code"]
    pub fn glucose_set_global_opt_subsumption_lim(
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered during simplification\n @param value  must be positive\n @return error code"]
    pub fn glucose_set_global_opt_simp_garbage_frac(value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Verbosity level (0=silent, 1=some, 2=more).\n @param value  must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_global_opt_verbosity(value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The constant used to force restart\n @param value must be in (GlucoseSolver*,0, 1)\n @return error code"]
    pub fn glucose_set_opt_K(arg1: *mut GlucoseSolver, value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The constant used to block restart\n @param value must be in (GlucoseSolver*,0, 5)\n @return error code"]
    pub fn glucose_set_opt_R(arg1: *mut GlucoseSolver, value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The size of moving average for LBD (GlucoseSolver*,restarts)\n @param value must be at least 10\n @return error code"]
    pub fn glucose_set_opt_size_lbd_queue(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The size of moving average for trail (GlucoseSolver*,block restarts)\n @param value  must be at least 10\n @return error code"]
    pub fn glucose_set_opt_size_trail_queue(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The number of conflicts before the first reduce DB (GlucoseSolver*,or the size of learnts if chanseok is used)\n @param value  must be a non-negative integer\n @return error code"]
    pub fn glucose_set_opt_first_reduce_db(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Increment for reduce DB\n @param value  must be a non-negative integer\n @return error code"]
    pub fn glucose_set_opt_inc_reduce_db(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Protect clauses if their LBD decrease and is lower than (GlucoseSolver*,for one turn)\n @param value must be a non-negative integer\n @return error code"]
    pub fn glucose_set_opt_lb_lbd_frozen_clause(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Chanseok Oh: all learnt clauses with LBD<=co are permanent\n @param value must be a positive integer greater than 1\n @return error code"]
    pub fn glucose_set_opt_chanseok_limit(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The min size required to minimize clause\n @param value must be at least 3\n @return error code"]
    pub fn glucose_set_opt_lb_size_minimzing_clause(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The min LBD required to minimize clause\n @param value must be at least 3\n @return error code"]
    pub fn glucose_set_opt_lb_lbd_minimzing_clause(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use inprocessing vivif (GlucoseSolver*,ijcai17 paper)\n @param value boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_lcm(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Updates LBD when doing LCM\n @param value boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_lcm_update_lbd(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The variable activity decay factor (GlucoseSolver*,starting point)\n @param value must be in (GlucoseSolver*,0, 1)\n @return error code"]
    pub fn glucose_set_opt_var_decay(arg1: *mut GlucoseSolver, value: f64)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The maximum variable activity decay factor\n @param value must be in (GlucoseSolver*,0, 1)\n @return error code"]
    pub fn glucose_set_opt_max_var_decay(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The clause activity decay factor\n @param value must be in (GlucoseSolver*,0, 1)\n @return error code"]
    pub fn glucose_set_opt_clause_decay(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The frequency with which the decision heuristic tries to choose a random variable\n @param value  must be in [0, 1]\n @return error code"]
    pub fn glucose_set_opt_random_var_freq(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Used by the random variable selection\n @param value must be positive\n @return error code"]
    pub fn glucose_set_opt_random_seed(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Controls conflict clause minimization (GlucoseSolver*,0=none, 1=basic, 2=deep)\n @param value must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_opt_ccmin_mode(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls phase saving (GlucoseSolver*,0=none, 1=basic, 2=deep)\n @param value must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_opt_phase_saving(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Randomize the initial activity\n @param value  boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_rnd_init_act(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered\n @param value must be positive\n @return error code"]
    pub fn glucose_set_opt_garbage_frac(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shrink clauses by asymmetric branching\n @param value boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_use_asymm(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check if a clause is already implied. (GlucoseSolver*,costly)\n @param value boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_use_rcheck(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Perform variable elimination.\n @param value boolean value (GlucoseSolver*,1=true, 0=false)\n @return error code"]
    pub fn glucose_set_opt_use_elim(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Allow a variable elimination step to grow by a number of clauses.\n @param value\n @return error code"]
    pub fn glucose_set_opt_grow(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit\n @param value must be -1 or a positive integer\n @return error code"]
    pub fn glucose_set_opt_clause_lim(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Do not check if subsumption against a clause larger than this. -1 means no limit.\n @param value must be -1 or a positive integer\n @return error code"]
    pub fn glucose_set_opt_subsumption_lim(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered during simplification\n @param value  must be positive\n @return error code"]
    pub fn glucose_set_opt_simp_garbage_frac(
        arg1: *mut GlucoseSolver,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Verbosity level (GlucoseSolver*,0=silent, 1=some, 2=more).\n @param value  must be 0, 1, or 2\n @return error code"]
    pub fn glucose_set_opt_verbosity(
        arg1: *mut GlucoseSolver,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glucose_new_solver() -> *mut GlucoseSolver;
}
extern "C" {
    #[doc = " @brief  Add a new variable to the solver.\n @param solver\n @return variable id"]
    pub fn glucose_new_var(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Add a clause to the solver.\n @param solver\n @param ps  array of literals\n @param length  length of the array\n @return boolean value"]
    pub fn glucose_add_clause(
        solver: *mut GlucoseSolver,
        ps: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Add the empty clause to the solver.\n @param solver\n @return boolean value"]
    pub fn glucose_add_empty_clause(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get the value of a literal.\n @param solver\n @param x  literal\n @return 0 if false, 1 if true, 2 if undefined"]
    pub fn glucose_value(
        solver: *mut GlucoseSolver,
        x: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get the value of a literal in the model.\n @param solver\n @param x  literal\n @return 0 if false, 1 if true, 2 if undefined"]
    pub fn glucose_model_value(
        solver: *mut GlucoseSolver,
        x: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem with assumptions.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false  (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn glucose_solve_assumps(
        solver: *mut GlucoseSolver,
        assumps: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_ulong,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem with limited.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false  (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn glucose_solve_limited(
        solver: *mut GlucoseSolver,
        assumps: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_ulong,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem.\n @param solver\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false  (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn glucose_solve(
        solver: *mut GlucoseSolver,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Perform variable elimination based simplification.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param turn_off_elim  boolean value, recommand false  (1=true, 0=false)"]
    pub fn glucose_eliminate(
        solver: *mut GlucoseSolver,
        turn_off_elim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The current number of assigned literals.\n @param solver\n @return The current number of assigned literals."]
    pub fn glucose_nassigns(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The current number of original clauses.\n @param solver\n @return"]
    pub fn glucose_nclauses(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The current number of learnt clauses.\n @param solver\n @return"]
    pub fn glucose_nlearnts(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The current number of variables.\n @param solver\n @return"]
    pub fn glucose_nvars(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glucose_nfree_vars(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn glucose_destroy(solver: *mut GlucoseSolver);
}
extern "C" {
    #[doc = " @brief  Check if the solver is okay.\n @param solver\n @return boolean value"]
    pub fn glucose_okay(solver: *mut GlucoseSolver) -> ::std::os::raw::c_int;
}
