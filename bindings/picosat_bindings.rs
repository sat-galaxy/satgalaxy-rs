/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [::std::os::raw::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_short_backupbuf"]
        [::std::mem::offset_of!(_IO_FILE, _short_backupbuf) - 119usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PicoSATSolver {
    _unused: [u8; 0],
}
extern "C" {
    pub fn picosat_s_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn picosat_s_config() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn picosat_s_copyright() -> *const ::std::os::raw::c_char;
}
pub type picosat_s_malloc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type picosat_s_realloc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type picosat_s_free = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ),
>;
extern "C" {
    #[doc = " @brief Initializes a new PicoSAT solver instance (constructor).\n @return Pointer to the initialized PicoSATSolver."]
    pub fn picosat_s_init() -> *mut PicoSATSolver;
}
extern "C" {
    #[doc = " @brief Initializes a PicoSAT solver with custom memory management functions.\n @param state User-defined state for memory management.\n @param m Malloc function for memory allocation.\n @param r Realloc function for memory reallocation.\n @param f Free function for memory deallocation.\n @return Pointer to the initialized PicoSATSolver."]
    pub fn picosat_s_minit(
        state: *mut ::std::os::raw::c_void,
        m: picosat_s_malloc,
        r: picosat_s_realloc,
        f: picosat_s_free,
    ) -> *mut PicoSATSolver;
}
extern "C" {
    #[doc = " @brief Destroys a PicoSAT solver instance (destructor).\n @param solver Pointer to the PicoSATSolver to reset."]
    pub fn picosat_s_reset(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Enters the PicoSAT solver context.\n @param solver Pointer to the PicoSATSolver."]
    pub fn picosat_s_enter(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Exits the PicoSAT solver context.\n @param solver Pointer to the PicoSATSolver."]
    pub fn picosat_s_leave(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @param solver Pointer to the PicoSATSolver.\n @param file Output file for solver messages (default: stdout)."]
    pub fn picosat_s_set_output(solver: *mut PicoSATSolver, file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Measure all time spent in all calls in the solver.  By default only the time spent in 'picosat_s_sat' is measured.\n @param solver Pointer to the PicoSATSolver.\n @note Enabling this may significantly increase time for adding large CNFs due to getrusage calls."]
    pub fn picosat_s_measure_all_calls(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @param solver Pointer to the PicoSATSolver.\n @param prefix String prefix for verbose messages and statistics (default: \"c \")."]
    pub fn picosat_s_set_prefix(solver: *mut PicoSATSolver, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @param solver Pointer to the PicoSATSolver.\n @param new_verbosity_level Verbosity level (1+ for detailed progress reports).\n @note Reports are printed to the output file set by picosat_s_set_output, prefixed by picosat_s_set_prefix."]
    pub fn picosat_s_set_verbosity(
        solver: *mut PicoSATSolver,
        new_verbosity_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @param solver Pointer to the PicoSATSolver.\n @param new_plain_value Non-zero to disable preprocessing (plain solving), zero to enable.\n @note Currently affects only failed literal probing."]
    pub fn picosat_s_set_plain(solver: *mut PicoSATSolver, new_plain_value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Sets the default initial phase for decision variables.\n @param solver Pointer to the PicoSATSolver.\n @param phase Phase value: 0 (false), 1 (true), 2 (Jeroslow-Wang, default), 3 (random).\n @note After first assignment, variables reuse their previous value for decisions.\n @return None."]
    pub fn picosat_s_set_global_default_phase(
        solver: *mut PicoSATSolver,
        phase: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the initial phase for a specific variable when chosen as a decision variable.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to set the phase for.\n @param phase Phase value: negative (false), positive (true), 0 (use global default phase).\n @note Forced assignments override this phase for decision variables.\n @return None."]
    pub fn picosat_s_set_default_phase_lit(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
        phase: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Resets all variable phases to their default state.\n @param solver Pointer to the PicoSATSolver.\n @return None."]
    pub fn picosat_s_reset_phases(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Erases variable scores, keeping learned clauses and literal pointers.\n @param solver Pointer to the PicoSATSolver.\n @note Incremental mode may differ from a fresh CNF due to retained clauses.\n @return None."]
    pub fn picosat_s_reset_scores(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Resets assignment in SAT state and removes a percentage of less active learned clauses.\n @param solver Pointer to the PicoSATSolver.\n @param percentage Percentage of large learned clauses to remove (100% removes all).\n @return None."]
    pub fn picosat_s_remove_learned(solver: *mut PicoSATSolver, percentage: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @brief Sets priority for decision variables.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to mark as more important.\n @note Default is all variables marked as indifferent."]
    pub fn picosat_s_set_more_important_lit(solver: *mut PicoSATSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Sets priority for decision variables.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to mark as less important.\n @note Default is all variables marked as indifferent."]
    pub fn picosat_s_set_less_important_lit(solver: *mut PicoSATSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Prints a message to the solver's internal output file.\n @param solver Pointer to the PicoSATSolver.\n @param verbosity_level Verbosity level required for the message to be printed.\n @param fmt Format string for the message.\n @param ... Additional arguments for the format string.\n @return None."]
    pub fn picosat_s_message(
        solver: *mut PicoSATSolver,
        verbosity_level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Sets the seed for the random number generator used in random decisions.\n @param solver Pointer to the PicoSATSolver.\n @param random_number_generator_seed Seed value for the random number generator.\n @note Useful for benchmarking different parameter sets, less effective for industrial examples.\n @return None."]
    pub fn picosat_s_set_seed(
        solver: *mut PicoSATSolver,
        random_number_generator_seed: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Enables proof trace generation for extracting cores or traces.\n @param solver Pointer to the PicoSATSolver.\n @note Must be called immediately after picosat_s_init. Not needed for picosat_s_set_incremental_rup_file.\n @note Trace generation may not be included if compiled with full optimization (e.g., './configure -O').\n @return Non-zero if trace generation is supported, zero otherwise."]
    pub fn picosat_s_enable_trace_generation(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets a file for incremental RUP proof trace dumping.\n @param solver Pointer to the PicoSATSolver.\n @param file Output file for the RUP trace.\n @param m Maximum number of variables.\n @param n Number of original clauses.\n @note Reduces memory usage but dumped clauses may not be in the clausal core.\n @return None."]
    pub fn picosat_s_set_incremental_rup_file(
        solver: *mut PicoSATSolver,
        file: *mut FILE,
        m: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Saves original clauses for use with picosat_s_deref_partial.\n @param solver Pointer to the PicoSATSolver.\n @return None."]
    pub fn picosat_s_save_original_clauses(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Allocates and returns the next unused variable index.\n @param solver Pointer to the PicoSATSolver.\n @note The variable is treated as used in future calls to picosat_s_sat, picosat_s_deref, and picosat_s_changed.\n @return The next available variable index."]
    pub fn picosat_s_inc_max_var(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Push and pop semantics for PicoSAT.   'picosat_s_push' opens up a new\n context.  All clauses added in this context are attached to it and\n discarded when the context is closed with 'picosat_s_pop'.  It is also\n possible to nest contexts.\n\n The current implementation uses a new internal variable for each context.\n However, the indices for these internal variables are shared with\n ordinary external variables.  This means that after any call to\n 'picosat_s_push', new variable indices should be obtained with\n 'picosat_s_inc_max_var' and not just by incrementing the largest variable\n index used so far.\n\n @param solver Pointer to the PicoSATSolver..\n @return The return value is the index of the literal that assumes this context.\n This literal can only be used for 'picosat_s_failed_context' otherwise\n it will lead to an API usage error."]
    pub fn picosat_s_push(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief This is as 'picosat_s_failed_assumption', but only for internal variables\n generated by 'picosat_s_push'.\n @param solver\n @param lit\n @return boolean value"]
    pub fn picosat_s_failed_context(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief\n @param solver\n @return the literal that assumes the current context or zero if the outer context has been reached."]
    pub fn picosat_s_context(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Closes the current context and recycles the literal generated for assuming this context.\n @return return value is the literal for the new outer context or zero if the outer most context has been reached."]
    pub fn picosat_s_pop(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Forces immediate removal of satisfied clauses and those in closed contexts.\n @param solver Pointer to the PicoSATSolver.\n @note Called internally after sufficient units are learned or contexts closed (MAXCILS limit).\n @note Retains learned clauses involving outer contexts.\n @return None."]
    pub fn picosat_s_simplify(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Optimizes variable table size to reduce resizing.\n @param solver Pointer to the PicoSATSolver.\n @param max_idx Estimated maximum variable index.\n @note Has the same effect as picosat_s_inc_max_var but optimizes allocation.\n @return None."]
    pub fn picosat_s_adjust(solver: *mut PicoSATSolver, max_idx: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return  Number of variables (p cnf <m> n)."]
    pub fn picosat_s_variables(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return  Number of original clauses (p cnf m <n>)."]
    pub fn picosat_s_added_original_clauses(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return  Maximum memory allocated."]
    pub fn picosat_s_max_bytes_allocated(solver: *mut PicoSATSolver) -> usize;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return Current process time."]
    pub fn picosat_s_time_stamp() -> f64;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return  None (prints to output file)."]
    pub fn picosat_s_stats(solver: *mut PicoSATSolver);
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @param file Output file for picosat_s_stats (others return directly).\n @return  Number of propagations."]
    pub fn picosat_s_propagations(solver: *mut PicoSATSolver) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return  Number of decisions."]
    pub fn picosat_s_decisions(solver: *mut PicoSATSolver) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return Number of visits."]
    pub fn picosat_s_visits(solver: *mut PicoSATSolver) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " @brief Retrieves solver statistics.\n @param solver Pointer to the PicoSATSolver.\n @return Time spent in library calls or picosat_s_sat (if picosat_s_measure_all_calls enabled)."]
    pub fn picosat_s_seconds(solver: *mut PicoSATSolver) -> f64;
}
extern "C" {
    #[doc = " @brief Adds literals or clauses to the solver incrementally.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to add (picosat_s_add).\n @note Adding a literal resets the previous assignment.\n @return The original clause index (starting at 0) for the added literal or clause."]
    pub fn picosat_s_add(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Adds literals or clauses to the solver incrementally.\n @param solver Pointer to the PicoSATSolver.\n @param ... Variable argument list of literals terminated by zero (picosat_s_add_arg).\n @note Adding a literal resets the previous assignment.\n @return The original clause index (starting at 0) for the added literal or clause."]
    pub fn picosat_s_add_arg(solver: *mut PicoSATSolver, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Adds literals or clauses to the solver incrementally.\n @param solver Pointer to the PicoSATSolver.\n @param lits Array of literals terminated by zero (picosat_s_add_lits).\n @note Adding a literal resets the previous assignment.\n @return The original clause index (starting at 0) for the added literal or clause."]
    pub fn picosat_s_add_lits(
        solver: *mut PicoSATSolver,
        lits: *const ::std::os::raw::c_int,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Prints the CNF to a file in DIMACS format.\n @param solver Pointer to the PicoSATSolver.\n @param file Output file for the CNF.\n @return None."]
    pub fn picosat_s_print(solver: *mut PicoSATSolver, file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Adds an assumption for the next picosat_s_sat call.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to assume (interpreted as a unit clause).\n @note Assumptions are valid only for the next picosat_s_sat call and are cleared afterward unless reassumed.\n @note Assumptions remain valid post-picosat_s_sat for picosat_s_failed_assumption until picosat_s_add, picosat_s_assume, or another picosat_s_sat is called.\n @return None."]
    pub fn picosat_s_assume(solver: *mut PicoSATSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Adds a literal to the global all-different constraint (ADC).\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to add to the ADC.\n @note Only one global ADC is supported; all bit-vectors must have identical bit-width.\n @note TODO: Handle top-level assigned literals.\n @return None."]
    pub fn picosat_s_add_ado_lit(solver: *mut PicoSATSolver, lit: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Runs the main SAT solving routine.\n @param solver Pointer to the PicoSATSolver.\n @param decision_limit Maximum number of decisions (negative for no limit).\n @return picosat_s_SATISFIABLE, picosat_s_UNSATISFIABLE, or picosat_s_UNKNOWN."]
    pub fn picosat_s_sat(
        solver: *mut PicoSATSolver,
        decision_limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets a propagation limit for picosat_s_sat.\n @param solver Pointer to the PicoSATSolver.\n @param limit Maximum number of propagations.\n @note Must be called after picosat_s_init and before picosat_s_sat.\n @return None."]
    pub fn picosat_s_set_propagation_limit(
        solver: *mut PicoSATSolver,
        limit: ::std::os::raw::c_ulonglong,
    );
}
extern "C" {
    #[doc = " @brief Returns the result of the last picosat_s_sat call.\n @param solver Pointer to the PicoSATSolver.\n @return Last picosat_s_sat result or 0 if not called."]
    pub fn picosat_s_res(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Dereferences a literal to get its assignment after picosat_s_sat returns picosat_s_SATISFIABLE.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to dereference.\n @return 1 (true), -1 (false), or 0 (unknown)."]
    pub fn picosat_s_deref(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if a literal is forced at the top level.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to check.\n @note Does not require picosat_s_sat and does not reset incremental usage.\n @return 1 (true), -1 (false), or 0 (unknown)."]
    pub fn picosat_s_deref_toplevel(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves a partial satisfying assignment for original clauses after picosat_s_sat returns picosat_s_SATISFIABLE.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to dereference.\n @note Requires picosat_s_save_original_clauses to be called after initialization.\n @return 1 (true), -1 (false), or 0 (unknown)."]
    pub fn picosat_s_deref_partial(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if the CNF is unsatisfiable due to an empty clause.\n @param solver Pointer to the PicoSATSolver.\n @return Non-zero if unsatisfiable due to an empty clause, zero otherwise."]
    pub fn picosat_s_inconsistent(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if a literal is a failed assumption in the last picosat_s_sat call.\n @param solver Pointer to the PicoSATSolver.\n @param lit Literal to check.\n @note Only valid while current assumptions are active (see picosat_s_assume).\n @return Non-zero if the literal is a failed assumption, zero otherwise."]
    pub fn picosat_s_failed_assumption(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns a zero-terminated list of failed assumptions from the last picosat_s_sat call.\n @param solver Pointer to the PicoSATSolver.\n @note Valid until the next picosat_s_sat or picosat_s_failed_assumptions call.\n @note Only meaningful if picosat_s_sat returned picosat_s_UNSATISFIABLE.\n @return Pointer to a zero-terminated array of failed assumptions."]
    pub fn picosat_s_failed_assumptions(solver: *mut PicoSATSolver)
        -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Computes a minimized list of failed assumptions from the last picosat_s_sat call.\n @param solver Pointer to the PicoSATSolver.\n @param state User-defined state for the callback.\n @param callback Function called for each simplified assumption set (receives state and reduced assumptions).\n @param fix Non-zero to permanently assign assumptions (true for necessary, false for redundant).\n @note Only meaningful if picosat_s_sat returned picosat_s_UNSATISFIABLE.\n @note Valid until the next picosat_s_sat, picosat_s_mus_assumptions, or this function call.\n @return Pointer to a zero-terminated minimized array of failed assumptions."]
    pub fn picosat_s_mus_assumptions(
        solver: *mut PicoSATSolver,
        state: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_int,
            ),
        >,
        fix: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Computes a maximal satisfiable subset of assumptions.\n @param solver Pointer to the PicoSATSolver.\n @note Requires assumptions set and picosat_s_sat called with picosat_s_inconsistent checked.\n @note Reassumes all assumptions before returning.\n @note Setting assumption phases to true may improve performance.\n @return Pointer to a zero-terminated array of consistent assumptions."]
    pub fn picosat_s_maximal_satisfiable_subset_of_assumptions(
        solver: *mut PicoSATSolver,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Iterates over maximal satisfiable subsets of assumptions.\n @param solver Pointer to the PicoSATSolver.\n @note Requires assumptions set via picosat_s_assume; calls picosat_s_sat internally unless inconsistent.\n @note Adds a blocking clause to rule out the returned subset, altering the CNF.\n @note Setting assumption phases to true may improve performance.\n @return Pointer to a zero-terminated array of consistent assumptions or NULL if none remain."]
    pub fn picosat_s_next_maximal_satisfiable_subset_of_assumptions(
        solver: *mut PicoSATSolver,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Iterates over minimal correcting assumption sets.\n @param solver Pointer to the PicoSATSolver.\n @note Each assumed literal appears once in the result, even if assumed multiple times.\n @note Setting assumption phases to true may improve performance.\n @return Pointer to a zero-terminated array of minimal correcting assumptions."]
    pub fn picosat_s_next_minimal_correcting_subset_of_assumptions(
        solver: *mut PicoSATSolver,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Computes the union of all minimal correcting assumption sets (HUMUS).\n @param solver Pointer to the PicoSATSolver.\n @param callback Function called after each minimal correcting set (receives state, nmcs, nhumus).\n @param state User-defined state for the callback.\n @note Renders the CNF inconsistent after one call; requires solver reset.\n @note Uses picosat_s_next_minimal_correcting_subset_of_assumptions internally.\n @return Pointer to a zero-terminated array of assumptions in the HUMUS."]
    pub fn picosat_s_humus(
        solver: *mut PicoSATSolver,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                state: *mut ::std::os::raw::c_void,
                nmcs: ::std::os::raw::c_int,
                nhumus: ::std::os::raw::c_int,
            ),
        >,
        state: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if the assignment of old variables changed between picosat_s_sat calls returning SATISFIABLE.\n @param solver Pointer to the PicoSATSolver.\n @note Valid until picosat_s_add, picosat_s_assume, or picosat_s_sat is called.\n @note May return non-zero even if no change occurred due to internal flip tracking (TODO: exact tracking not implemented).\n @return 0 if old variable assignments are unchanged, non-zero if they might have changed."]
    pub fn picosat_s_changed(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Determines if the i'th original clause is in the clausal core.\n @param solver Pointer to the PicoSAT solver.\n @param i Clause index from picosat_s_add (0 <= i < picosat_s_added_original_clauses).\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Incremental mode with assumptions tested only for picosat_s_corelit; may not work reliably here.\n @return Non-zero if the clause is in the core, zero otherwise."]
    pub fn picosat_s_coreclause(
        solver: *mut PicoSATSolver,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if a literal is in the variable core (resolved in deriving the empty clause).\n @param solver Pointer to the PicoSAT solver.\n @param lit Literal to check.\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Tested in incremental mode with assumptions; other core functions may not work reliably.\n @return Non-zero if the literal is in the variable core, zero otherwise."]
    pub fn picosat_s_corelit(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Writes clauses used in deriving the empty clause to a file in DIMACS format.\n @param solver Pointer to the PicoSAT solver.\n @param core_file Output file for the clausal core.\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Incremental mode with assumptions tested only for picosat_s_corelit; may not work reliably here.\n @return None."]
    pub fn picosat_s_write_clausal_core(solver: *mut PicoSATSolver, core_file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Writes a compact proof trace in TraceCheck format to a file.\n @param solver Pointer to the PicoSAT solver.\n @param trace_file Output file for the proof trace.\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Incremental mode with assumptions tested only for picosat_s_corelit; may not work reliably here.\n @return None."]
    pub fn picosat_s_write_compact_trace(solver: *mut PicoSATSolver, trace_file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Writes an extended proof trace in TraceCheck format to a file.\n @param solver Pointer to the PicoSAT solver.\n @param trace_file Output file for the proof trace.\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Incremental mode with assumptions tested only for picosat_s_corelit; may not work reliably here.\n @return None."]
    pub fn picosat_s_write_extended_trace(solver: *mut PicoSATSolver, trace_file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Writes a RUP trace of learned core clauses to a file.\n @param solver Pointer to the PicoSAT solver.\n @param trace_file Output file for the RUP trace.\n @note Requires trace generation enabled via picosat_s_enable_trace_generation after picosat_s_init.\n @note Unlike picosat_s_set_incremental_rup_file, only includes learned core clauses.\n @note Incremental mode with assumptions tested only for picosat_s_corelit; may not work reliably here.\n @return None."]
    pub fn picosat_s_write_rup_trace(solver: *mut PicoSATSolver, trace_file: *mut FILE);
}
extern "C" {
    #[doc = " @brief Checks if a literal was used in resolution to derive a learned clause.\n @param solver Pointer to the PicoSAT solver.\n @param lit Literal to check.\n @note Core literals are a subset of used literals; does not require keeping proof traces.\n @return Non-zero if the literal was used, zero otherwise."]
    pub fn picosat_s_usedlit(
        solver: *mut PicoSATSolver,
        lit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn picosat_s_error(solver: *mut PicoSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn picosat_s_errmsg(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
