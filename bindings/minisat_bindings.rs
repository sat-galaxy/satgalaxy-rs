/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiniSATSolver {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief get error message by error code\n @param code error code\n @return message"]
    pub fn minisat_error_msg(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief The variable activity decay factor\n @param value must be in (0, 1)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_var_decay(arg1: *mut MiniSATSolver, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The clause activity decay factor\n @param value must be in (MiniSATSolver*,0, 1)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_clause_decay(
        arg1: *mut MiniSATSolver,
        decay: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The frequency with which the decision heuristic tries to choose a random variable\n @param value must be in [0,1]\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_random_var_freq(
        arg1: *mut MiniSATSolver,
        freq: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Used by the random variable selection\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_random_seed(
        arg1: *mut MiniSATSolver,
        seed: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls conflict clause minimization\n @param value must be 0, 1, or 2 (MiniSATSolver*,0=none, 1=basic, 2=deep)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_ccmin_mode(
        arg1: *mut MiniSATSolver,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls the level of phase saving\n @param value must be 0, 1, or 2 (MiniSATSolver*,0=none, 1=limited, 2=full)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_phase_saving(
        arg1: *mut MiniSATSolver,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Randomize the initial activity\n @param value boolean value (MiniSATSolver*,0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_rnd_init_act(
        arg1: *mut MiniSATSolver,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use the Luby restart sequence\n @param value boolean value (MiniSATSolver*,0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_luby_restart(
        arg1: *mut MiniSATSolver,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The base restart interval\n @param value must be a positive integer\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_restart_first(
        arg1: *mut MiniSATSolver,
        restart_first: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Restart interval increase factor\n @param value must be at least 1.0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_restart_inc(
        arg1: *mut MiniSATSolver,
        restart_inc: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_garbage_frac(
        arg1: *mut MiniSATSolver,
        garbage_frac: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Minimum learnt clause limit\n @param value must be at least 0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_min_learnts_lim(
        arg1: *mut MiniSATSolver,
        min_learnts_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shrink clauses by asymmetric branching\n @param value boolean value (MiniSATSolver*,0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_use_asymm(
        arg1: *mut MiniSATSolver,
        opt_use_asymm: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check if a clause is already implied (MiniSATSolver*,costly)\n @param value boolean value (MiniSATSolver*,0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_use_rcheck(
        arg1: *mut MiniSATSolver,
        opt_use_rcheck: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Perform variable elimination\n @param value boolean value (MiniSATSolver*,0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_use_elim(
        arg1: *mut MiniSATSolver,
        opt_use_elim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allow a variable elimination step to grow by a number of clauses\n @param value must be at least 0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_grow(
        arg1: *mut MiniSATSolver,
        opt_grow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Variables are not eliminated if it produces a resolvent with a length above this limit\n @param value must be at least -1 (MiniSATSolver*,-1 means no limit)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_clause_lim(
        arg1: *mut MiniSATSolver,
        opt_clause_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Do not check if subsumption against a clause larger than this\n @param value must be at least -1 (MiniSATSolver*,-1 means no limit)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_subsumption_lim(
        arg1: *mut MiniSATSolver,
        opt_subsumption_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered during simplification\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_simp_garbage_frac(
        arg1: *mut MiniSATSolver,
        opt_simp_garbage_frac: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verbosity level\n @param value must be 0, 1, or 2 (MiniSATSolver*,0=silent, 1=some, 2=more)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_opt_verbosity(
        arg1: *mut MiniSATSolver,
        verb: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The variable activity decay factor\n @param value must be in (0, 1)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_var_decay(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The clause activity decay factor\n @param value must be in (0, 1)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_clause_decay(decay: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The frequency with which the decision heuristic tries to choose a random variable\n @param value must be in [0,1]\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_random_var_freq(freq: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Used by the random variable selection\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_random_seed(seed: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls conflict clause minimization\n @param value must be 0, 1, or 2 (0=none, 1=basic, 2=deep)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_ccmin_mode(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Controls the level of phase saving\n @param value must be 0, 1, or 2 (0=none, 1=limited, 2=full)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_phase_saving(
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Randomize the initial activity\n @param value boolean value (0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_rnd_init_act(
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Use the Luby restart sequence\n @param value boolean value (0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_luby_restart(
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The base restart interval\n @param value must be a positive integer\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_restart_first(
        restart_first: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Restart interval increase factor\n @param value must be at least 1.0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_restart_inc(restart_inc: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_garbage_frac(garbage_frac: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Minimum learnt clause limit\n @param value must be at least 0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_min_learnts_lim(
        min_learnts_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shrink clauses by asymmetric branching\n @param value boolean value (0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_use_asymm(
        opt_use_asymm: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check if a clause is already implied (costly)\n @param value boolean value (0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_use_rcheck(
        opt_use_rcheck: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Perform variable elimination\n @param value boolean value (0=false, others=true)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_use_elim(
        opt_use_elim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allow a variable elimination step to grow by a number of clauses\n @param value must be at least 0\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_grow(opt_grow: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Variables are not eliminated if it produces a resolvent with a length above this limit\n @param value must be at least -1 (-1 means no limit)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_clause_lim(
        opt_clause_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Do not check if subsumption against a clause larger than this\n @param value must be at least -1 (-1 means no limit)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_subsumption_lim(
        opt_subsumption_lim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The fraction of wasted memory allowed before a garbage collection is triggered during simplification\n @param value must be positive\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_simp_garbage_frac(
        opt_simp_garbage_frac: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verbosity level\n @param value must be 0, 1, or 2 (0=silent, 1=some, 2=more)\n @return error code, 0 for success, others for invalid parameter"]
    pub fn minisat_set_global_opt_verbosity(verb: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minisat_new_solver() -> *mut MiniSATSolver;
}
extern "C" {
    #[doc = " @brief  Add a new variable to the solver.\n @param solver\n @return variable id"]
    pub fn minisat_new_var(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minisat_release_var(solver: *mut MiniSATSolver, l: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief  Add a clause to the solver.\n @param solver\n @param ps  array of literals\n @param length  length of the array\n @return boolean value"]
    pub fn minisat_add_clause(
        solver: *mut MiniSATSolver,
        ps: *const ::std::os::raw::c_int,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Add the empty clause to the solver.\n @param solver\n @return boolean value"]
    pub fn minisat_add_empty_clause(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get the value of a literal.\n @param solver\n @param x  literal\n @return 0 if false, 1 if true, 2 if undefined"]
    pub fn minisat_value(
        solver: *mut MiniSATSolver,
        x: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get the value of a literal in the model.\n @param solver\n @param x  literal\n @return 0 if false, 1 if true, 2 if undefined"]
    pub fn minisat_model_value(
        solver: *mut MiniSATSolver,
        x: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem with assumptions.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn minisat_solve_assumps(
        solver: *mut MiniSATSolver,
        assumps: *const ::std::os::raw::c_int,
        length: usize,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem with limited.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false  (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn minisat_solve_limited(
        solver: *mut MiniSATSolver,
        assumps: *const ::std::os::raw::c_int,
        length: usize,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Solve the problem.\n @param solver\n @param do_simp  boolean value, recommand true (1=true, 0=false)\n @param turn_off_simp  boolean value, recommand false  (1=true, 0=false)\n @return 10 for sat, 20 for unsat, 30 for unkown"]
    pub fn minisat_solve(
        solver: *mut MiniSATSolver,
        do_simp: ::std::os::raw::c_int,
        turn_off_simp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Perform variable elimination based simplification.\n @param solver\n @param assumps  array of assumptions\n @param length  length of the array\n @param turn_off_elim  boolean value, recommand false  (1=true, 0=false)"]
    pub fn minisat_eliminate(
        solver: *mut MiniSATSolver,
        turn_off_elim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The current number of assigned literals."]
    pub fn minisat_nassigns(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The current number of original clauses."]
    pub fn minisat_nclauses(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The current number of learnt clauses."]
    pub fn minisat_nlearnts(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The current number of variables."]
    pub fn minisat_nvars(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minisat_nfree_vars(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minisat_destroy(solver: *mut MiniSATSolver);
}
extern "C" {
    #[doc = " @brief  Check if the solver is okay.\n @param solver\n @return boolean value"]
    pub fn minisat_okay(solver: *mut MiniSATSolver) -> ::std::os::raw::c_int;
}
